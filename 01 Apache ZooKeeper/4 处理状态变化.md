## 处理状态变化
### 4.1 监视点与通知
我们在之前讲过，备份主节点需要知道主节点是否已经崩溃，从节点需要知道任务是否被分配给了自己。这些特点使得应用程序需要随时得知ZooKeeper集群的状态。为了满足这一点，客户端可以定时对ZooKeeper集群进行轮询，以检查系统状态是否发生了变化。但是，轮询是一种不太理想的做法。考虑到ZooKeeper集群中庞大的节点数量，如果我们将轮询的周期设置得太短，那么轮询所消耗的请求量将十分大，而在这些请求中，大部分是没有必要的；如果我们将轮询的周期设置得太短，那么客户端可能无法及时地获知到状态的变化，当节点崩溃时，其恢复的时间也将增加。

为了避免轮询的调优和流量问题，ZooKeeper提供了处理状态变化的机制，它就是监视点（watch）。这种机制使得客户端能够仅对感兴趣的具体事件（即一个znode节点的更新操作）进行及时的状态感知。监视点是一个与之关联的znode节点和事件类型所构成的单次触发器。监视点被触发时会产生一条通知。通知时注册了监视点的应用客户端收到的事件报告消息。因此，监视点和通知组成了一个通用机制，它使客户端能观察与获取变化情况。

回到单次触发器的概念，这里的 “单次” 表明了监视点的生命周期只有一次事件周期。换句话说，当znode节点发生变化，如数据更新、节点被删除等，那么监视点生效一次，至此也完成了它的使命。对于下一次znode节点的状态变化，如果不重新创建监视点，那么将无法获知到znode节点的变化。这种设计将衍生出一种问题，那就是当一个客户端在接收到通知后、注册一个新的监视点时，可能会丢失事件。ZooKeeper的状态信息能够弥补这一缺陷，它保存了任何在接收通知与注册新的监视点之间所发生的变化情况。

假设一个从节点接收到一个新任务分配给它的通知。为了接收新任务，从节点将读取任务列表，而此时又有新的任务分配给了该从节点。从节点在通过getChildren方法调用获取任务列表时，能获取到所有的任务。在调用getChildren方法时，也可以设置新的监视点，从而保证从节点不会丢失任务。这是将多个事件分摊到一个通知上的具体表现，显然这种机制可使事件通知变得轻量化。

### 4.2 设置监视点
ZooKeeper提供的三类读操作方法（getData、getChildren、exists）均可以为znode节点设置监视点。使用监视点需要实现Watcher接口中的process方法：

```java
public void process(WatchedEvent event); 
```

这里的WatchedEvent包括两类信息：ZooKeeper会话状态、事件类型。其中会话状态包括六种类型：Disconnected、SyncConnected、ConnectedReadOnly、SaslAuthenticated、Expired；事件类型包括NodeCreated、NodeDeleted、NodeDataChanged、NodeChildrenChanged和None五种。前三个事件类型只涉及单节点，第四个事件类型涉及节点的子节点。当事件类型不是None时，将返回znode路径，当事件类型为Node时，表示无事件发生，仅ZooKeeper的会话状态发生了变化。
监视点分为数据监视点和子节点监视点两类。创建、删除或设置一个znode节点的数据可触发数据监视点，exists和getData两个方法可以设置数据监视点。只有getChildren方法可以设置子节点监视点，这种监视点只有在子节点创建或删除时才会触发。对于不同的事件类型，可以采用不同方法设置监视点：

|Case/API|getData|getChildren|exists|
|----:|:----:|:----:|:----:|
|NodeCreated|-|-|Yes|
|NodeDeleted|Yes|-|Yes|
|NodeDataChanged|Yes|-|Yes|
|NodeChildrenChanged|-|Yes|-|
